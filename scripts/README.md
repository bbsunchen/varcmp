###Introduction

This directory contains scripts and auxiliary data files used in the
manuscript. The following list gives brief descriptions:

 * **k8-darwin** and **k8-linux**: Mac and Linux binaries for the [K8 Javascript
   interpreter][1]. K8 is based on [Google's V8 engine][2] with extended
   support for file reading and binary arrays. All the Javascript scripts in
   this directory should be launched with `k8 script.js`.

 * **bio8.js**: a collection of simple utilities, mostly for processing VCF and
   BED files.

 * **vcf-extra-info.js**: annotate or compute some common statistics from
   single-sample VCFs (see Section 2.4). These statistics include
   low-complexity (qLC), per-site depth (qDP), min depth on either strand
   (qDS), Fisher's strand bias P-value (qFS) and allele balance (qAB). It only
   works with GATK, FreeBayes, Platypus, SAMtools VCFs, and VCFs converted by
   cg2vcf from bio8.js. See the following note about why this script is
   necessary.

 * **vcf-extra-flt.js**: filter VCFs generated by vcf-extra-info.js.

 * **pair-qst1.js**: compute the number of homozygous (hom) transitions (ts),
   homozygous transversions (tv), heterozygous (het) ts, het tv, insertions,
   and deletions from a pair of VCFs (in our case, they are a NA12878 VCF and a
   CHM1 VCF), stratified by QUAL or a tag in the input VCFs. It was used to
   produce Figure 1 and 5 in the manuscript.

 * **1000g.hwe-bad.bed**: regions with excessively high read depth and
   excessive heterozygotes (see Section 3.3.3).

 * **LCR-hs37d5.bed.gz**: low-complexity regions (see Section 2.4).

 * **process1.mk**: Makefile for processing one single-sample VCF.

 * **process2.mk**: Makefile for processing a pair of CHM1-NA12878 VCFs.

###Caller-oblivious statistics

Different variant callers output site information in different VCF tags. For
example, SAMtools has DP4, but FreeBayes splits it into four tags; Platypus
also splits DP4 into four tags but with different names. These differences
make it difficult to uniformly process VCFs produced by different callers.

Script **vcf-extra-info.js** aims to re-annotate VCFs based on the
caller-specific information such that we can apply the same set of filters to
different call sets. Using different filters or different filter thresholds
is probably is the leading cause of the relatively small intersection between
call sets.
<!--
###Why Javascript?

Most of scripts were written in Javascript with K8 extensions. Here are the
reasons: 

 * Google's V8 Javascript engine is very efficient. For many tasks, it
   by far outperforms the vast majority of scripting languages. It may even
   occasionally match the performance of C programs.

 * I use regular expression (regex) a lot for text processing. V8 comes with
   *THE* fastest regex engine among all scripting languages. I haven't seen a
   better one so far.

 * K8 extendeds V8 with efficient file reading and C-style dynamic binary
   arrays, which are essential to file processing.

 * K8 can be compiled into a single binary with all the functionalities. It
   is light-weight.

 * I like the syntax of C.

However, K8 is a hobby project which I have never taken seriously. It is too
simplistic to most programmers. I wouldn't recommend others to use it.
-->
[1]: https://github.com/attractivechaos/k8
[2]: https://code.google.com/p/v8/
